<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Truck Locations</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }
    .status {
      position: absolute; top: 8px; left: 8px;
      background: #fff; padding: 6px 8px; border-radius: 6px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      box-shadow: 0 1px 4px rgba(0,0,0,.2); z-index: 9999;
    }
  </style>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
</head>
<body>
  <div class="status" id="status">Loading…</div>
  <div id="map"></div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script>
    // ================== CONFIG ==================
    // IMPORTANT: set this to your Python backend base URL.
    // It MUST be HTTPS when this page is served from GitHub Pages.
    // Example: "https://smartcar-backend-yourname.onrender.com"
    const BACKEND_BASE = "https://YOUR-BACKEND-URL";
    const REFRESH_MS = 30000;   // match your backend poll interval
    const SHOW_AGE = true;      // set false to hide "age …s" on labels

    // Optional friendly name overrides by vehicle ID (fill after you see IDs in /locations)
    const NAME_OVERRIDES = {
      // "veh_id_1": "Zaid",
      // "veh_id_2": "Jacob",
      // "veh_id_3": "Al",
    };
    // ============================================

    const statusEl = document.getElementById('status');

    // Mixed-content guard: GitHub Pages is HTTPS; block if backend is HTTP
    if (location.protocol === 'https:' && BACKEND_BASE.startsWith('http://')) {
      statusEl.textContent = 'Blocked: backend must be HTTPS when page is HTTPS.';
    }

    const map = L.map('map');
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

    const markers = {}; // id -> Leaflet marker
    let firstFit = true;
    let userMoved = false;

    map.on('movestart', () => userMoved = true);

    function labelFor(v) {
      const name = NAME_OVERRIDES[v.id] || v.name || 'Truck';
      return SHOW_AGE ? `${name} • age ${v.age_s}s` : name;
    }

    async function refresh() {
      try {
        const url = BACKEND_BASE.replace(/\/$/, '') + '/locations?x=' + Date.now();
        const r = await fetch(url, { cache: 'no-store', mode: 'cors', credentials: 'omit' });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const data = await r.json();

        if (!Array.isArray(data)) {
          statusEl.textContent = data && data.error ? ('Error: ' + data.error) : 'No data';
          return;
        }

        statusEl.textContent = `Vehicles: ${data.length}`;
        const latlngs = [];

        for (const v of data) {
          const latlng = [v.lat, v.lon];
          latlngs.push(latlng);
          if (!markers[v.id]) {
            const m = L.marker(latlng).addTo(map);
            m.bindTooltip(labelFor(v), { permanent: true, direction: 'top', offset: [0, -10] });
            markers[v.id] = m;
          } else {
            markers[v.id].setLatLng(latlng);
            markers[v.id].setTooltipContent(labelFor(v));
          }
        }

        if ((firstFit || !userMoved) && latlngs.length) {
          map.fitBounds(L.latLngBounds(latlngs), { padding: [30, 30] });
          firstFit = false;
        }
      } catch (e) {
        statusEl.textContent = 'Fetch failed: ' + e.message;
      }
    }

    refresh();
    setInterval(refresh, REFRESH_MS);
  </script>
</body>
</html>
